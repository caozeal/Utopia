### TDD的优势
1. 完整准确的可执行文档。————只有代码能准确而实时地呈现当前开发状态，一个或多个场景的测试用例便精确地表达了一个用户故事，任何需求上的变化，在TDD中，都要首先修改相应的测试，进而修改代码使能满足当前测试。代码与测试相互印证，而测试又完全服务于用户故事。
2. 更好的设计。————与传统开发所要求的预先设计不同，TDD要求着眼点关注于当下，不做预先设计。在传统开发中，即使水平很高的开发者也很难预先便做出完美的设计，往往伴随在开发中不断的修改、更正、完善，其中或许某个开发中的灵感-有更好的实现方式，或许设计中漏掉了某个“小点”、而导致整个设计需要推倒重来，与TDD相比，预先设计缺少灵活性。使用TDD时，不用预先设计，相反，不断编写并实现规范的过程中，设计通常会变得清晰（这并不是不需要设计，而是设计着眼于当下，随时根据变化完善修改设计）。并且，易于测试地代码都是设计良好的。联想到我们再开发后补充单元测试、为遗留代码补充单元测试，通常是痛苦而为难地，有时候甚至需要为了测试而在实现代码中做一些“后门”，来使得测试更容易，并不难发现，这部分代码通常也是缺乏设计、甚至于十分糟糕的代码，TDD便可以避免这种情况。
3. 更健壮的系统。————TDD的副产品之一便是大量的测试，这些测试保证了系统能够满足当前需求，保证了系统的健壮性。当前大量的测试带来的维护困难，也是TDD经常受诟病的一块，修改需求，必须修改相应的测试，进而再修改代码来满足测试。在不使用TDD的开发者中，修改测试是种额外的负担，但是任何需求上的改变，首先体现在测试中，进而再修改代码，这正是TDD的正常工作流程。前边也提到，这些测试不仅不是额外的负担，而是非常可靠信赖的可执行文档，是比任何不可执行的需求文档、设计文档、测试文档更能准确无误的反映出我们系统目前的状态。而要达到查阅友好的地步，除了大量的测试外，测试类的位置、测试类、方法、变量的命名、测试方法的简洁等等最佳实践都需要思考、练习并应用到实际开发中。友好而全面的测试，甚至于可以完全取代需求文档、设计文档、测试文档等等，这些节省下的时间，是可以与修改编写测试占用的时间相抵消的。
4. 使用BDD，可以完成用户故事->测试->开发->发布整个流程。
5. 与一般敏捷开发提倡的相同，TDD也是一种小步快跑的开发模式，每次添加一个用户故事其中一个场景的测试，进而开发满足测试的相应的代码，在响应需求变化、随时发版上也是有着天然的支持。
6. 正如流程中红灯-绿灯-重构中所表述的一样，重构在TDD中乃是家常便饭，每天都回去重构数十次，而有了完善的单元测试的支持，也给与我们重构的勇气，我们相信重构后的代码只要能满足现有单元测试，一定是没有问题的。遵循小步快跑的原则，每次重构也是尽量不要改动大量的代码，每次重构之后都要运行所有单元测试来查看是否绿灯，一旦红灯，便说明我们的重构是有问题的，需要撤销操作，重新考虑重构的方式。

### TDD最佳实践
TDD的最佳实践有很多，下面挑几个我认为目前比较重要和有代表性的简要说一下：
1. 将实现代码和测试代码分开。测试代码有自己的测试包，单元测试推行之前，代码中存在着大量的main函数测试方法与业务代码混合在一起，可谓是脏乱差，这样的测试只能影响代码的整洁度，丝毫起不到文档和帮助维护代码的作用。
2. 将测试类和实现放到一个包中。
3. 以类似于受测类的方式给测试类命名。这两条可以更方便的查找测试类和实现类。
4. 给测试方法指定描述性名称。可以按照BDD那样命名，Given,When,Then。要做到阅读了方法名称，就知道它是做什么的。注意，**不要依赖于注释**！注释不会在生成的测试报告中出现。
5. 每次修改代码后，都要运行所有的测试。不要仅运行当前测试，要确保修改的代码不会带来意料之外的副作用。
6. 仅当所有测试都通过后才编写新测试。
7. 仅当测试都通过后才重构。
8. 不要让测试依赖其他测试。保证测试的独立性。

## 单元测试
一个单元测试通常包含的部分：测试条件+Mock(模拟依赖)+待测试方法+Assert(断言)

### 测试框架：JUnit、TestNG

### 模拟框架：Mokito、EasyMock、PowerMock

### 增强断言框架：AssertJ、Hamcrest

### 设计原则
1. YAGNI原则： You Ain't Gonna Need It(你不会需要它)，要尽力消除冗余代码，专注于当前需求，不做过度设计。代码越少，需要维护的代码就越少。这与传统开发中一些人提倡的预先做完善的设计、尽可能做详尽的考虑不同，多余的设计意味着多余的代码，其中很多的代码今后都可能不会再用到，永久的被冷落在角落，占用着维护的精力和资源。TDD中的频繁重构和快速相应，提供了消除大量冗余代码的资本。
2. DRY原则：Don't Repeat Yourself(不要自我重复)。重用而不是复制以前的代码，使得需要维护的代码更少，并且有助于从代码中提出新的抽象层级。
3. KISS原则：Keep It Simple Stupid(保持简单)。保持单元测试的简单，保持实现代码的简单，越简单的东西，越不容易出错，越能实现功能，正所谓大道至简，繁琐的东西通常由于糟糕的设计或是技术的妥协。
4. 奥卡姆剃刀原理：“如果你有两个或多个类似的解决方案，选择最简单的”。多思考，相处不同的解决方案，并选择其中最简单的，不要一想到方案就去做，要想想是否是更好的、更优雅的、更简单的。
5. SOLID原则：面向对象设计的基本原则（单一职责、开闭、里式替换、接口分离、依赖倒置、（迪米特法则/最少知道原则））
